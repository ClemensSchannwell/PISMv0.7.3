#!/usr/bin/env python
# Copyright (C) 2008 Constantine Khroulev, Jed Brown and Ed Bueler
#
# This file is part of PISM.
#
# PISM is free software; you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
#
# PISM is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License
# along with PISM; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# 
# This file is based on (and is intended to replace) 'ncgen.rb'.

from sys import argv, exit
from os.path import basename
from subprocess import Popen, PIPE

script_name = basename(argv[0])

# Inputs:
cdl_input = 'pism_state.cdl'
diag_input = 'pism_diag.fragment'

# Outputs:
write_attributes = 'write_attributes.c'
write_diag_attributes = 'write_diag_attributes.c'

autogen_warning = """// This file was automatically generated by `%s' from
// `%s'.  If you edit it, your changes will be overwritten
// on the next invocation of `%s'.\n""" % (script_name, cdl_input, script_name)
autogen_warning_diag = """// This file was automatically generated by `%s' from
// `%s' and '%s'.  If you edit it,
// your changes will be overwritten
// on the next invocation of `%s'.\n""" % (script_name, cdl_input, diag_input, script_name)

def create_write_attributes(diag = False):
    try:
        cdl_input_file = open(cdl_input, "r")
        diag_input_file = open(diag_input, "r")
    except IOError:
        print "Could not open input files. Bailing out."
        exit(-1)
    try:
        ncgen = Popen(["ncgen", "-v2", "-c", "-"], stdin=PIPE, stdout=PIPE)
    except OSError:
        print "Could not execute 'ncgen'.\nPlease make sure it is in your PATH and try again."
        exit(-1)

    if diag:
        fname = write_diag_attributes
    else:
        fname = write_attributes

    try:
        output = open(fname, "w")
    except OIError:
        print "Could not open %s. Bailing out." % (fname)
        exit(-1)

    # Feed all the contents of 'pism_state.cdl' to ncgen, but stop at the line
    # containing the phrase "global attributes":
    for line in cdl_input_file:
        if line.find("global attributes") > -1: #Find returns the substring position or -1 on failure.
            break
        ncgen.stdin.write(line)

    # Insert the diagnostic quantities (if asked to):
    if diag:
        for line in diag_input_file:
            ncgen.stdin.write(line)

    # Feed the rest of 'pism_state.cdl' to ncgen:
    for line in cdl_input_file:
        ncgen.stdin.write(line)

    # Produce the output file:
    if diag:
        output.write(autogen_warning_diag)
    else:
        output.write(autogen_warning)

    # ncgen produces the output only after we do this:
    ncgen.stdin.close()

    process_the_code(ncgen.stdout, output, diag)

    # Do the clean-up:
    ncgen.stdout.close()
    cdl_input_file.close()
    diag_input_file.close()
    output.close()

def process_the_code(input, output, diag = False):
    # Define the pairs of strings to replace:
    pairs = [("91", "grid.Mx"), ("92", "grid.My"), ("93", "grid.Mz"), ("94", "grid.Mbz")]
    if diag:
        pairs.append(('"pism_state.nc"','diag_fname'))
    else:
        pairs.append(('"pism_state.nc"','fname'))

    # Skip everything until the beginning of the main() function:
    for line in input:
        if line.find("main()") > -1:
            break

    for line in input:
        if line.find("attribute vectors") > -1:
            continue
        if line.find("leave define mode") > -1:
            break
        output.write(replace_all(line, pairs))

        if line.find("enter define mode") > -1:
            output.write("if (grid.rank == 0) {\n")

    output.write("} // end if (grid.rank == 0)\n")


def replace_all(str, pairs):
    """str is a string, pairs is a list of tuples.
    Returns a new string, replacing the first element of each tuple with the second.

    >>> replace_all("foo quux", [("foo", "baz"), ("quux", "bang!")])
    --> 'baz bang!'
    
    Be careful: the order of pairs matters!"""
    for each in pairs:
        str = str.replace(each[0], each[1])
    return str

if __name__ == "__main__":
    create_write_attributes(False)
    create_write_attributes(True)
