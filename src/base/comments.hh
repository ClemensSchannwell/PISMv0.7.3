// THE ONLY PURPOSE OF THIS FILE IS TO BE A LOCATION FOR MAJOR SOURCE CODE COMMENTS.
// IT NEEDS TO BE A .hh (OR OTHER STANDARD SOURCE TYPE) AND IT NEEDS TO BE IN THE
// pism/src/ TREE SO THAT doxygen WILL AUTOMATICALLY READ IT.


// add commentary and GPL to first page of doxygen-erated HTML source browser
/*! @cond BROWSER \mainpage 
 *
 * This source browser shows the C++ class (object) structure of PISM.  It 
 * shows \em all the classes in PISM, \em all the inheritance structure and
 * \em all the members (variables and methods) of all the PISM classes.  
 * It was automatically generated by doxygen (http://www.doxygen.org/)
 * from comments in the PISM source code.
 *
 * See https://gna.org/projects/pism/ to download the PISM source code.  See 
 * http://www.pism-docs.org/ for all documentation of PISM.
 *
 * See the PISM User's Manual (http://www.pism-docs.org/manual.pdf) for help
 * with installing and using PISM.  
 * Most users should stick to the User's Manual for quite a while; only when 
 * a user needs to extend PISM is a look at this source browser really 
 * worthwhile.
 *
 * See the PISM Reference Manual (http://www.pism-docs.org/refman.pdf)
 * for a useful subset of this source browser
 * in PDF form.  The Reference Manual contains the minimum documentation 
 * of the PISM class structure in order to document 
 * the continuum models and numerical methods of PISM.  (Such continuum model
 * and numerical method documentation is widely scattered in this source browser.)
 *
 * There is also a source code <i>repository</i> browsing tool at the PISM download site
 * (https://gna.org/projects/pism/).  That tool is <i>very different from this one</i>.  This one
 * documents the C++ class structure of the current revision.  The one at gna.org
 * shows changes between revisions but it ignors the class structure as it only cares 
 * about source code files as text files and generally ignors their semantics.
 *
 * <i>
 * Copyright (C) 2008 Ed Bueler
 *
 * This document is part of PISM.
 *
 * PISM is free software; you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 2 of the License, or (at your option) any later
 * version.
 *
 * PISM is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PISM; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * </i>
 * @endcond
 */
 

// add commentary and GPL to first page of doxygen-erated PDF Reference Manual
/*! @cond REFMAN \mainpage


<h2>Author</h2>

Ed Bueler

 
<h2>Purpose</h2>

This \e Reference \e Manual documents the \em continuum \em models and \em numerical
\em methods in PISM.

This \e Manual is organized by C++ class.  

Most users should start with the <i>PISM User's Manual</i>
 
      http://www.pism-docs.org/manual.pdf  

for help with installing and using PISM.  Really smart know-it-all developers
should \e also at least glance at what is in the <i>User's Manual</i> before 
getting too far into this <i>Reference Manual</i>.

This <i>Manual</i> is a greatly shortened version of a thorough HTML
source code browser.  That browser can be generated from a copy of the PISM source by 
<tt>cd pism/doc/ && make</tt> .   Then use a web browser like Firefox to view
\c pism/doc/doxy/html/index.html .
 
This \e Manual was automatically generated by doxygen (http://www.doxygen.org/) from 
comments in the PISM source code.  Most of the source files from which this \e Manual 
was created are in the <tt>pism/src/base/</tt> subdirectory, but not all files or methods
(or even classes) are documented here; the only documented parts are the ones for which 
doxygen-type comments are given in the source code.  By contrast, the source 
code browser includes all the classes, class members, and source files in PISM.

 
<h2>GNU Public License</h2>

<i>
Copyright (C) 2008 Ed Bueler

This document is part of PISM.

PISM is free software; you can redistribute it and/or modify it under the
terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later
version.

PISM is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
details.

You should have received a copy of the GNU General Public License
along with PISM; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
</i>

 
<h2>The PISM source code</h2>

<h3> Overview</h3>  
PISM is implemented as a collection of C++ object classes, the most central of which is \c IceModel.  
There are five basic classes to know about, the sources for each of which are in \c pism/src/base/:
  - \c MaterialType.  Various materials are derived from the class \c MaterialType which merely defines 
       a couple of physical constants.  \c IceType is a derived class, but still an abstract class.  It \
       defines the physical properties of ice as a material.  Concrete classes derived from \c IceType
       are \c ThermoGlenIce (which uses the EISMINT constants) and \c GKIce as well as \c HybridIce, 
       which implements the Goldsby-Kohlstedt flow law CITE{GoldsbyKohlstedt}.  FOOTNOTE{Actually, it is 
       difficult or impossible to implement a complete Goldsby-Kohlstedt \c IceType because the effective
       viscosity (inverse) form of the constitutive relation is required for computation of SSA velocity 
       fields. \c HybridIce is Goldsby-Kohlstedt ice in SIA regions and Glen ice in other regions.}  
       There is a basal material type \c BasalType which can be plastic or linearly viscous.  Similarly, 
       there are \c BedrockType and \c OceanType types which define associated physical constants.
  - \c IceGrid.  Describes the computational box and grid, and the parallel layout of the grid.  
       (That is, which processor owns which part of the grid.)
  - \c IceModel.  Contains myriad data structures, flags, PETSc \c Vecs (below), and most of the methods 
       and numerical methods of PISM.
  - \c IceModelVec.  Abstracts the idea of a scalar field distributed across the PISM grid.  Elements of 
       this class can read and write themselves to NetCDF files, for instance.  The three dimensional 
       case, the derived class \c IceModelVec3, can hand back a requested column or stencil, for instance.
  - \c NCTool.  Collects the methods which read and write and regrid the actual PETSc \c Vecs in PISM.

Additional classes are \c Data1D and \c LocalInterpCtx but these are details.

<i>CITATIONS CAN BE FIGURED OUT BY LOOKING IN <tt>pism/src/doc/ice_bib.bib</tt>; SOMEDAY I'LL 
FIGURE OUT HOW TO GET CITATIONS IN doxygen.</i>
 
<h3>IceModel: Overview</h3>
The methods for \c IceModel are many.  In addition to numerics, they initialize the model 
(from input data files; several derived classes initialize from formulas describing simplified 
geometry experiments or exact solutions), they read user options, they allocate arrays in a 
distributed manner under PETSc, they control diagnostic viewers, they run the adaptive time-stepping 
mechanism, they report the state of PISM to the user, and they write out the model state to files.

A derived class of \c IceModel called \c IceCompModel is used for verification.  It has additional 
structures which allow compensatory sources and compute initial conditions from, and errors relative to,
known exact solutions CITE{BLKCB,BBL,BB}.  Another derived class used for verification is 
\c IceExactSSAModel, which implements the exact solution described in CITE{SchoofStream}.

Other derived classes of \c IceModel are \c IceEISModel, \c IceGRNModel, and \c IceROSSModel.  
These correspond to the EISMINT II simplified geometry experiments CITE{EISMINT00}, and the 
EISMINT-Greenland ice sheet and EISMINT-Ross ice shelf models described in the \e User's \e Manual.

There are five established drivers which just call constructors and destructors for an instance 
of \c IceModel, or a derived class thereof, and tell the instance to run itself.  These are in the 
source files \c pgrn.cc, \c pismd.cc, \c pismr.cc, \c pisms.cc, and \c pismv.cc, corresponding to 
the executables with the same names.  The drivers \c pismr.cc and \c pismd.cc only use the base 
class \c IceModel, so one is required to initialize from a PISM model state NetCDF file with 
\c -if or from an incomplete model state NetCDF file using \c -bif.

The different derived classes generally invoke the same numerical procedures to handle the various 
partial differential equations of the continuum model.  In the case of \c IceCompModel and
\c IceExactSSAModel, this fact is at the heart of the verification mechanism.


<h2>PETSc: An overview for PISM users</h2>

The PETSc library \CITE{petsc-user-ref,petsc-efficient} provides essential support for distributed 
arrays and linear solvers in a parallel computing environment.  ``PETSc'' stands for 
``Portable, Extensible Toolkit for Scientific Computation.''  It is a suite of data structures 
and routines in C for the scalable parallel solution of partial differential equations and their 
scientific applications.  Large parts of PETSc relate especially to finite-difference-type regular, 
rectangular grids but PETSc has been used for unstructured grids as well.

PETSc employs the MPI standard for all message-passing communicationbut it is deliberately at a 
higher level of abstraction than MPI.  We find that using PETSc protects the programmer from 
explicit consideration of message passing about 90% of the time.

Documentation for PETSc is at 

http://www-unix.mcs.anl.gov/petsc/petsc-as/.

Although PISM is a C++ program, PETSc is a C library.  All PISM calls to PETSc use standard (ANSI) C.

<h3>PETSc types</h3>
Most important variables in a PETSc program are of these types:
  - \c DA
  - \c Vec
  - \c KSP

In fact most of the PETSc types merely declare pointers, but these types should be regarded 
as abstract data types.  Variables must be created with calls to functions like \c DACreate2d(), 
\c VecCreate(), etc., and destroyed when no longer needed.

<h3>Distributed arrays and vectors</h3>
PETSc has an abstract date type called a Distributed Array (type \c DA).  \c DAs contain 
information about the grid and stencil.  They set up \e ghosted values which are intended to
duplicate the values on neighboring processors so communication can be done in big batches.

Vectors (type \verb|Vec|) are created with \texttt{DAVecCreate()} and similar. These vectors will be distributed across the processors as indicated by the distributed array.

There are two parameters of note: stencil type and stencil width.  The stencil types are
\verb|DA_STENCIL_STAR| and \verb|DA_STENCIL_BOX|.  They are generalizations of the five
point and nine point stencils typical of two dimensional discretizations respectively.  In
particular, \verb|DA_STENCIL_STAR| indicates that ghosted points (information owned by a
different processor) will be needed only along the coordinate axes while
\verb|DA_STENCIL_BOX| indicates that ghosted points will be needed in the box shaped
region surrounding each point.  The stencil width indicates how many points in each
direction will be needed.  We never need a stencil width greater than 1 and only need BOX
style stencils when gradient terms must be evaluated on a staggered grid ($h$ in SIA
velocity and $\bar{u},\bar{v}$ in computation of effective viscosity in SSA
velocity).  Keeping all other two dimensional vectors on a STAR type stencil
would reduce the necessary communication slightly, but would complicate the code.  For this
reason, all two dimensional vectors are kept on a box type distributed array.

The three dimensional distributed arrays are aligned so that they have the same horizontal
extent as the associated two dimensional distributed array, but have complete vertical
extent. One point of confusion is the redefinition of the $x,y,z$ axes. Contrary to the
PETSc default, our $z$ axis changes most rapidly through memory while the $x$ axis changes
most slowly. That is, our C style arrays will be addressed as \texttt{u[i][j][k]} where
$\texttt{i,j,k}$ are the coordinate indices in the directions $x,y,z$ respectively.

DA-based vectors can be accessed by \texttt{DAVecGetArray()} and restored with
\texttt{DAVecRestoreArray()}. The resulting pointer should be addressed using normal
multidimensional array indexing where values range over the global array.

PETSc DA based vectors can be ``local'' or ``global''. Local vectors include space for the
ghosted points. That is, when \texttt{DAVecGetArray()} is called, the resulting array can
be indexed on all the ghosted points. However, all vector operations act only on the local
portion. \texttt{DALocalToLocalBegin()} and then \texttt{DALocalToLocalEnd()} should be
called to update the ghost points before they will be needed. Global vectors do not hold
ghosted values, but array operations will act on the entire vector. Hence local vectors
typically need to be mapped to global vectors before viewing or using in a linear system.
This is achieved with \texttt{DALocalToGlobal()}.

\subsubsection*{Solving linear systems}
PETSc is designed for solving large, sparse systems in a distributed environment.
Iterative methods are the name of the game and especially Krylov subspace methods such as
conjugate gradients and GMRES. For consistency, all methods use the Krylov subspace
interface. For this, the user declares an object of type \texttt{KSP}. Various options can
be set and the preconditioner context can be extracted. PETSc has an options database
which holds command line options. To allow these options to influence the \t{KSP}, one
should call \t{KSPSetFromOptions()} prior to solving the system. The default method is
GMRES(30) with ILU preconditioning.

To solve the system, a matrix must be attached to the \t{KSP}. The first time
\t{KSPSolve()} is called, the matrix will be factored by the preconditioner and reused
when the system is called for additional right hand sides. The default matrix format is
similar to the Matlab \t{sparse} format. Each processor owns a range of rows. Elements in
matrices and vectors can be set using \t{MatSetValues()} and \t{VecSetValues()}. These
routines use the global indexing and can set values on any processor. The values are
cached until one calls \t{MatAssemblyBegin()} followed by \t{MatAssemblyEnd()} to
communicate the values.

In the SSA velocity computation, the solution and right hand side vectors are not DA
based.

The vector (field) components are interlaced and distributed. This seemed to be the
most straightforward method to solve the system (as opposed to using more advanced
features intended for multiple degrees of freedom on DA based vectors). This also allows
the matrix to have an optimal parallel layout.

\subsubsection*{PETSc utility functions}
The \t{PetscViewer} interface allows PETSc objects to be displayed. This can be in binary
to disk, in plain text to the terminal, in graphical form to an X server, to a running
instance of Matlab, etc. Typically, one will want to view an entire vector, not just the
local portion, so DA based local vectors are mapped to global vectors before viewing.

When viewing multiprocessor jobs, the display may have to be set on the command line, for instance as
\t{-display :0} or similar; this must be given as the final option.  For example,

\verb|mpiexec -n 2 pismv -test C -Mx 101 -My 101 -Mz 31 -y 1000 -d HT -display :0|

\noindent views a two processor run of test C.

PETSc allows the programmer to access command line arguments at any time during program
execution. This is preferable to using \t{getopt.h} for this purpose.

Quite ellaborate error tracing and performance monitoring is possible with PETSc.  All
functions return \t{PetscErrorCode} which should be checked by the macro \t{CHKERRQ()}.
Normally, runtime errors print traceback information when the program exits.  If this
information is not present, you may need to use a debugger which is accessible with the
command line options \verb|-start_in_debugger| and \verb|-on_error_attach_debugger|.  Also
consider options such as \verb|-log_summary| to get diagnostics written to the terminal.



 * @endcond
 */


/*! \fn PetscErrorCode IceModel::temperatureStep()
    \brief Takes a semi-implicit time-step for the temperature equation.

In summary, the conservation of energy equation is
    \f[ \rho c_p \frac{dT}{dt} = k \frac{\partial^2 T}{\partial z^2} + \Sigma,\f] 
where \f$T(t,x,y,z)\f$ is the temperature of the ice.  This equation is the shallow approximation
of the full three-dimensional conservation of energy.  Note \f$dT/dt\f$ stands for the material
derivative, so advection is included.  Here \f$\rho\f$ is the density of ice, 
\f$c_p\f$ is its specific heat, and \f$k\f$ is its conductivity.  Also \f$\Sigma\f$ is the volume
strain heating.

In summary, the numerical method is first-order upwind for advection and centered-differences with
semi-implicitness for the vertical conduction term.  We work from the bottom 
of the column upward in building the system to solve (in the semi-implicit time-stepping scheme).
The excess energy above pressure melting is converted to melt-water, and that a fraction 
of this melt water is transported to the base according to the scheme in excessToFromBasalMeltLayer().

The method uses equally-spaced calculation but the methods getValColumn(), setValColumn() interpolate 
back and forth from this equally-spaced calculational grid to the (usually) non-equally space storage 
grid.

In this procedure four scalar fields are modified: vHmelt, vbasalMeltRate, Tb3, and Tnew3.
But vHmelt, vbasalMeltRate and Tb3 will never need to communicate ghosted values (i.e. horizontal 
stencil neighbors.  The ghosted values for T3 are updated from the values in Tnew3 in the
communication done by temperatureAgeStep().
 
@cond REFMAN
Here is a more complete discussion and derivation.

Consider a column of a slowly flowing and heat conducting material as shown in the left side 
of the next figure.  (The left side shows a general column of flowing and heat conduction 
material showing a small segment \f$V\f$.  The right side shows a more specific column of ice 
flowing and sliding over bedrock.)  This is an \em Eulerian view so the material flows through 
a column which remains fixed (and is notional).  The column is vertical.  We will 
assume when needed that it is rectangular in cross-section with cross-sectional area 
\f$\Delta x\Delta y\f$.

\image latex earlycols.png "Left: a general column of material.  Right: ice over bedrock." width=3in

[FIXME: CONTINUE TO MINE eqns3D.tex FOR MORE]

The application of the geothermal flux at the base of a column is a special case for which 
we give a finite difference argument.  This scheme follows the equation (2.114) in 
Morton and Mayers (2005).  We have the boundary condition
	\f[  -k \frac{\partial T}{\partial z} = G(t,x,y) \f]
where \f$G(t,x,y)\f$ is the applied geothermal flux, and it is applied at level \f$z=-B_0\f$ 
in the bedrock (which is the only case considered here).  We <em> add a virtual lower grid 
point </em> \f$z_{-1} = z_0 - \Delta  z\f$ and we approximate the above boundary condition 
at $z_0$ by the centered-difference
	\f[  -k \frac{T_{1} - T_{-1}}{2 \Delta z} = G. \f]
Here \f$T_k = T_{ijk}^{l+1}\f$.  We also apply the discretized conduction equation at $z_0$.  These two combined equations 
yield a simplified form
	\f[(1 + 2 KR) T_0 - 2 K T_1 = T_0 + \frac{2\Delta t}{\rho c_p \Delta z} G \f]
where \f$K = k \Delta t (\rho c \Delta z^2)^{-1}\f$.

@endcond
 */



