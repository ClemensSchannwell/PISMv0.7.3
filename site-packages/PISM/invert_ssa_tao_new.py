# Copyright (C) 2012 David Maxwell
# 
# This file is part of PISM.
# 
# PISM is free software; you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# 
# PISM is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
# 
# You should have received a copy of the GNU General Public License
# along with PISM; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

# FIXME: TAO initialization here??

import PISM
from PISM.util import Bunch

def constructFunctionals(ssarun):
  vecs = ssarun.modeldata.vecs
  if vecs.has('vel_misfit_weight'):
    misfit_weight = vecs.vel_misfit_weight

  misfit_weight = None
  if vecs.has('vel_misfit_weight'):
    misfit_weight = vecs.vel_misfit_weight

  tauc_fixed_mask = None
  if vecs.has('tauc_fixed_mask'):
    tauc_fixed_mask = vecs.tauc_fixed_mask

  grid = ssarun.grid
  cL2 = grid.config.get("inv_ssa_cL2");
  cH1 = grid.config.get("inv_ssa_cH1");

  area = 4*grid.Lx*grid.Ly;
  length_scale = grid.config.get("inv_ssa_length_scale");
  cL2 /= area;
  cH1 /= area;
  cH1 *= (length_scale*length_scale);

  designFunctional = PISM.H1NormFunctional2S(grid,cL2,cH1,tauc_fixed_mask)    

  velocity_scale = grid.config.get("inv_ssa_velocity_scale")/PISM.secpera;

  stateFunctional = PISM.MeanSquareFunctional2V(grid,misfit_weight);    
  stateFunctional.normalize(velocity_scale);
  
  return (designFunctional,stateFunctional)

class InvSSASolver_Tikhonov:
  """Inverse SSA solver based on Tikhonov iteration using TAO."""
  
  tao_types = {'tiknew_lmvm':'tao_lmvm', 'tiknew_lcl':'tao_lcl', 'tikhonov_lmvm':'tao_lmvm', 'tikhonov_cg':'tao_cg', 'tikhonov_lcl':'tao_lcl', 'tikhonov_blmvm':'tao_blmvm'}

  def __init__(self,ssarun):
    self.ssarun = ssarun
    self.config = ssarun.config

    self.method = self.config.get_string('inv_ssa_method')

    self.listeners = []

  def solveForward(self,zeta,out=None):
    ssa = self.ssarun.ssa

    if not ssa.linearizeAt(zeta):
      raise Exception("")
    if out is not None:
      out.copy_from(ssa.solution())
    else:
      out = ssa.solution()
    return out

  def addIterationListener(self,listener):
    self.listeners.append(listener)

  def addXUpdateListener(self,listener):
    self.listeners.append(listener)

  def solveInverse(self,zeta0,u_obs,zeta_inv):
    eta = self.config.get("tikhonov_penalty_weight")

    tao_type = self.tao_types[self.method]
    (stateFunctional,designFunctional) = constructFunctionals(self.ssarun)
    if self.method == 'tiknew_lcl':
      self.ip = PISM.InvSSATikhonovLCL(self.ssarun.ssa,zeta0,u_obs,eta,stateFunctional,designFunctional)
      self.solver = PISM.InvSSATikhonovLCLSolver(self.ssarun.grid.com,tao_type,self.ip)
      pl = [ TikhonovLCLIterationListenerAdaptor(self,l) for l in self.listeners ]
    else:
      self.ip = PISM.SSATikhonovProblem(self.ssarun.ssa,zeta0,u_obs,eta,stateFunctional,designFunctional)
      self.solver = PISM.SSATikhonovSolver(self.ssarun.grid.com,tao_type,self.ip)
      pl = [ TikhonovIterationListenerAdaptor(self,l) for l in self.listeners ]
    for l in pl:
      self.ip.addListener(l)
    self.ip.setInitialGuess(zeta_inv)

    return self.solver.solve()

  def inverseSolution(self):
    zeta = self.ip.designSolution()
    u =    self.ip.stateSolution()
    return (zeta,u)

  def inverseConvergedReason(self):
    return self.solver.reasonDescription()

class TikhonovLCLIterationListenerAdaptor(PISM.InvSSATikhonovLCLListener):
  """Adaptor for passing listening events from a TAO-based LCL Tikhonov solver to a python object."""
  def __init__(self,owner,listener):
    PISM.InvSSATikhonovLCLListener.__init__(self)
    self.owner = owner
    self.listener = listener
  def iteration(self,problem,eta,it,objVal,penaltyVal,d,diff_d,grad_d,u,diff_u,grad_u,constraints):

    data = Bunch(eta=eta,designVal=objVal,stateVal=penaltyVal,
                      zeta=d,diff_zeta=diff_d,grad_zeta=grad_d,
                      u=u,r=diff_u,grad_u=grad_u,constraints=constraints)
    try:
      self.listener(self.owner,it,data)
    except Exception as e:
      logError("\nWARNING: Exception occured during an inverse solver listener callback:\n%s\n\n" % str(e))
    return 0

class TikhonovIterationListenerAdaptor(PISM.SSATikhonovProblemListener):
  """Adaptor for passing listening events from a TAO-based Tikhonov solver to a python object."""
  def __init__(self,owner,listener):
    PISM.SSATikhonovProblemListener.__init__(self)
    self.owner = owner
    self.listener = listener
  def iteration(self,problem,eta,it,objVal,penaltyVal,d,diff_d,grad_d,u,diff_u,grad_u,grad):
    data = Bunch(eta=eta,designVal=objVal,stateVal=penaltyVal,
                      zeta=d,diff_zeta=diff_d,grad_zeta=grad_d,
                      u=u,r=diff_u,grad_u=grad_u,grad=grad)
    try:
      self.listener(self.owner,it,data)
    except Exception as e:
      logError("\nWARNING: Exception occured during an inverse solver listener callback:\n%s\n\n" % str(e))
    return 0