# Copyright (C) 2012 David Maxwell
# 
# This file is part of PISM.
# 
# PISM is free software; you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation; either version 3 of the License, or (at your option) any later
# version.
# 
# PISM is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
# 
# You should have received a copy of the GNU General Public License
# along with PISM; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

# FIXME: TAO initialization here??

import PISM
from PISM.util import Bunch


class InvSSASolver_Tikhonov:
  """Inverse SSA solver based on Tikhonov iteration using TAO."""
  
  tao_types = {'tikhonov_lmvm':'tao_lmvm', 'tikhonov_cg':'tao_cg', 'tikhonov_lcl':'tao_lcl', 'tikhonov_blmvm':'tao_blmvm'}

  def __init__(self,ssarun,method):
    self.ssarun = ssarun
    self.config = ssarun.config
    self.method = method

    self.listeners = []

  def solveForward(self,zeta,out=None):
    ssa = self.ssarun.ssa

    reason = ssa.linearize_at(zeta)
    if reason.failed():
      raise PISM.AlgorithmFailureException(reason)
    if out is not None:
      out.copy_from(ssa.solution())
    else:
      out = ssa.solution()
    return out

  def addIterationListener(self,listener):
    self.listeners.append(listener)

  def addXUpdateListener(self,listener):
    self.listeners.append(listener)

  def solveInverse(self,zeta0,u_obs,zeta_inv):
    eta = self.config.get("tikhonov_penalty_weight")

    tao_type = self.tao_types[self.method]
    (stateFunctional,designFunctional) = PISM.invert_ssa.constructTikhonovFunctionals(self.ssarun)
    if self.method == 'tikhonov_lcl':
      self.ip = PISM.IP_SSATaucTaoTikhonovProblemLCL(self.ssarun.ssa,zeta0,u_obs,eta,stateFunctional,designFunctional)
      self.solver = PISM.IP_SSATaucTaoTikhonovProblemLCLSolver(self.ssarun.grid.com,tao_type,self.ip)
      pl = [ TikhonovLCLIterationListenerAdaptor(self,l) for l in self.listeners ]
    else:
      self.ip = PISM.IP_SSATaucTaoTikhonovProblem(self.ssarun.ssa,zeta0,u_obs,eta,stateFunctional,designFunctional)
      self.solver = PISM.IP_SSATaucTaoTikhonovSolver(self.ssarun.grid.com,tao_type,self.ip)
      pl = [ TikhonovIterationListenerAdaptor(self,l) for l in self.listeners ]
    for l in pl:
      self.ip.addListener(l)
    self.ip.setInitialGuess(zeta_inv)

    return self.solver.solve()

  def inverseSolution(self):
    zeta = self.ip.designSolution()
    u =    self.ip.stateSolution()
    return (zeta,u)

class TikhonovLCLIterationListenerAdaptor(PISM.IP_SSATaucTaoTikhonovProblemLCLListener):
  """Adaptor for passing listening events from a TAO-based LCL Tikhonov solver to a python object."""
  def __init__(self,owner,listener):
    PISM.IP_SSATaucTaoTikhonovProblemLCLListener.__init__(self)
    self.owner = owner
    self.listener = listener
  def iteration(self,problem,eta,it,objVal,penaltyVal,d,diff_d,grad_d,u,diff_u,grad_u,constraints):

    data = Bunch(eta=eta,designVal=objVal,stateVal=penaltyVal,
                      zeta=d,diff_zeta=diff_d,grad_zeta=grad_d,
                      u=u,r=diff_u,grad_u=grad_u,constraints=constraints)
    try:
      self.listener(self.owner,it,data)
    except Exception as e:
      logError("\nWARNING: Exception occured during an inverse solver listener callback:\n%s\n\n" % str(e))
    return 0

class TikhonovIterationListenerAdaptor(PISM.IP_SSATaucTaoTikhonovProblemListener):
  """Adaptor for passing listening events from a TAO-based Tikhonov solver to a python object."""
  def __init__(self,owner,listener):
    PISM.IP_SSATaucTaoTikhonovProblemListener.__init__(self)
    self.owner = owner
    self.listener = listener
  def iteration(self,problem,eta,it,objVal,penaltyVal,d,diff_d,grad_d,u,diff_u,grad_u,grad):
    data = Bunch(eta=eta,designVal=objVal,stateVal=penaltyVal,
                      zeta=d,diff_zeta=diff_d,grad_zeta=grad_d,
                      u=u,r=diff_u,grad_u=grad_u,grad=grad)
    try:
      self.listener(self.owner,it,data)
    except Exception as e:
      logError("\nWARNING: Exception occured during an inverse solver listener callback:\n%s\n\n" % str(e))
    return 0
