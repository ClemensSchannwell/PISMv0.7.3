# Copyright (C) 2011, 2012 David Maxwell
# 
# This file is part of PISM.
# 
# PISM is free software; you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation; either version 3 of the License, or (at your option) any later
# version.
# 
# PISM is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
# 
# You should have received a copy of the GNU General Public License
# along with PISM; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

import PISM
from PISM import netCDF

has_siple = False
try:
  import siple
  has_siple = True
except:
  pass

has_tao = False
try:
  PISM.__getattribute__('TaoInitializer')
  has_tao = True
except:
  pass

import math
from petsc4py import PETSc

from PISM.logging import logError, logMessage
import numpy as np
import sys


class SSATaucForwardRun(PISM.ssa.SSARun):
  """Subclass of :class:`PISM.ssa.SSARun` where the underlying SSA implementation is an :cpp:class:`IP_SSATaucForwardProblem`.
  It is responsible for putting together a :class:`PISM.model.ModelData` containing the auxilliary data
  needed for solving the SSA (:cpp:class:`IceModelVec`\s, :cpp:class:`EnthalpyConverter`, etc.) as well
  as the instance of :cpp:class:`IP_SSATaucForwardProblem` that will solve the SSA repeatedly in the course
  of solving an inverse problem.  This class is intended to be subclassed by test cases where the data 
  is not provided from an input file.  See also :class:`SSATaucForwardRunFromInputFile`."""

  def _constructSSA(self):
    """Returns an instance of :cpp:class:`IP_SSATaucForwardProblem` rather than
       a basic :cpp:class:`SSAFEM` or :cpp:class:`SSAFD`.  Called from :meth:`PISM.ssa.SSARun.setup`."""
    md = self.modeldata
    self.tauc_param = createTaucParam(self.config)
    return createSSATaucForwardProblem(md.grid,md.basal,md.enthalpyconverter,self.tauc_param,self.config)

  def _initSSA(self):
    """One-time initialization of the :cpp:class:`IP_SSATaucForwardProblem`. Called from :meth:`PISM.ssa.SSARun.setup`."""

    vecs = self.modeldata.vecs
    self.ssa.init(vecs.asPISMVars())

    if vecs.has('vel_bc'):
      self.ssa.set_boundary_conditions(vecs.bc_mask,vecs.vel_bc)

    # Cache the values of the coefficients at quadrature points once here.
    # Subsequent solves will then not need to cache these values.
    self.ssa.cacheQuadPtValues();

class SSATaucForwardRunFromInputFile(PISM.ssa.SSAFromInputFile):
  """Subclass of :class:`PISM.ssa.SSAFromInputFile` where the underlying SSA implementation is an 
  :cpp:class:`IP_SSATaucForwardProblem`. The vector data for the run is provided in an input :file:`.nc` file.
  This class is a hybrid of :class:`PISM.ssa.SSAFromInputFile` and :class:`PISM.ssa.SSATaucForwardRun`, both
  of which are :class:`PISM.ssa.SSARun`\s.  We inherit from :class:`PISM.ssa.SSAFromInputFile` to gain
  its specialized code and duplicates some smaller code blocks from :class:`SSATaucForwardRun`,
  not wanting to mess with Python's multiple inheritance."""
  
  def __init__(self,input_filename,inv_data_filename):
    """
    :param input_filename:    :file:`.nc` file containing generic PISM model data.
    :param inv_data_filename: :file:`.nc` file containing data specific to inversion (e.g. observed SSA velocities).
    """
    PISM.ssa.SSAFromInputFile.__init__(self,input_filename)
    self.inv_data_filename = inv_data_filename

  def _setFromOptions(self):
    """Initialize internal parameters based on command-line flags. Called from :meth:`PISM.ssa.SSARun.setup`."""
    PISM.ssa.SSAFromInputFile._setFromOptions(self)
    for o in PISM.OptionsGroup(PISM.Context().com,"","Vel2Tauc"):
      self.using_zeta_fixed_mask = PISM.optionsFlag("-use_zeta_fixed_mask","Keep tauc constant except where grounded ice is present",default=True)

  def _initGrid(self):
    """Initialize grid size and periodicity. Called from :meth:`PISM.ssa.SSARun.setup`."""
    # The implementation in PISM.ssa.SSAFromInputFile uses a non-periodic
    # grid only if the run is regional and "ssa_method=fem" in the config
    # file.  For inversions, we always use an FEM type method, so for
    # regional inversions, we always use a non-periodic grid.
    periodicity = PISM.XY_PERIODIC
    (pstring,pflag) = PISM.optionsListWasSet(self.grid.com,'-periodicity',"Grid periodicity",['x','y','xy', 'none'],'xy')
    if pflag:
      pdict = {'x':PISM.X_PERIODIC,   'y':PISM.Y_PERIODIC, 
               'xy':PISM.XY_PERIODIC, 'none':PISM.NOT_PERIODIC }
      periodicity = pdict[pstring]
    else:
      periodicity = PISM.XY_PERIODIC
      if self.is_regional:
        periodicity=PISM.NOT_PERIODIC
    PISM.util.init_grid_from_file(self.grid,self.boot_file,periodicity);

  def _initSSACoefficients(self):
    """Reads SSA coefficients from the input file. Called from :meth:`PISM.ssa.SSARun.setup`."""
    self._allocStdSSACoefficients()

    # Read PISM SSA related state variables
    #
    # Hmmm.  A lot of code duplication with SSAFromInputFile._initSSACoefficients.

    vecs = self.modeldata.vecs
    thickness = vecs.thickness; bed = vecs.bed; enthalpy = vecs.enthalpy
    mask = vecs.ice_mask; surface = vecs.surface

    # Read in the PISM state variables that are used directly in the SSA solver
    for v in [thickness, bed, enthalpy]:
      v.regrid(self.boot_file,True)

    # variables mask and surface are computed from the geometry previously read
    sea_level = 0 # FIXME setFromOption?
    gc = PISM.GeometryCalculator(sea_level, self.config)
    gc.compute(bed,thickness,mask,surface)

    if PISM.util.fileHasVariable(self.boot_file,'ssa_driving_stress_x'):
      vecs.add( PISM.util.standardDrivingStressX(self.grid))
      vecs.ssa_driving_stress_x.regrid(self.boot_file,critical=True)

    if PISM.util.fileHasVariable(self.boot_file,'ssa_driving_stress_y'):
      vecs.add( PISM.util.standardDrivingStressY(self.grid))
      vecs.ssa_driving_stress_y.regrid(self.boot_file,critical=True)

    if self.is_regional:
      vecs.add( PISM.util.standardNoModelMask(self.grid), 'no_model_mask' )
      vecs.no_model_mask.regrid(self.boot_file,True)
      vecs.add( vecs.surface, 'usurfstore')
      vecs.setPISMVarsName('usurfstore','usurfstore')

    if self.config.get_flag('ssa_dirichlet_bc'):
      vecs.add( PISM.util.standard2dVelocityVec( self.grid, name='_ssa_bc', desc='SSA velocity boundary condition',intent='intent' ), "vel_ssa_bc" )
      has_u_ssa_bc = PISM.util.fileHasVariable(self.boot_file,'u_ssa_bc');
      has_v_ssa_bc = PISM.util.fileHasVariable(self.boot_file,'v_ssa_bc');
      if (not has_u_ssa_bc) or (not has_v_ssa_bc):
        PISM.verbPrintf(2,self.grid.com, "Input file '%s' missing Dirichlet boundary data u/v_ssa_bc; using zero default instead." % self.boot_file)
        vecs.vel_ssa_bc.set(0.)
      else:
        vecs.vel_ssa_bc.regrid(self.boot_file,True)

      if self.is_regional:
        vecs.add( vecs.no_model_mask, 'bc_mask')
      else:
        vecs.add( PISM.util.standardBCMask( self.grid ), 'bc_mask' )
        bc_mask_name = vecs.bc_mask.string_attr("name")
        if PISM.util.fileHasVariable(self.boot_file,bc_mask_name):
          vecs.bc_mask.regrid(self.boot_file,True)          
        else:
          PISM.verbPrintf(2,self.grid.com,"Input file '%s' missing Dirichlet location mask '%s'.  Default to no Dirichlet locations." %(self.boot_file,bc_mask_name))
          vecs.bc_mask.set(0)
      # We call this variable 'bc_mask' in the python code, it is called
      # 'bcflag' when passed between pism components, and it has yet
      # another name when written out to a file.  Anyway, we flag its
      # export to PISMVars name here.
      vecs.setPISMVarsName('bc_mask','bcflag')

    vecs.add( PISM.util.standardVelocityMisfitWeight(self.grid) )
    weight = vecs.vel_misfit_weight
    weight.regrid(self.inv_data_filename,True)

    zeta_fixed_mask = PISM.IceModelVec2Int()
    zeta_fixed_mask.create(self.grid, 'zeta_fixed_mask', True, self.grid.max_stencil_width);
    zeta_fixed_mask.set_attrs("model_state", "tauc_unchanging integer mask", "", "");
    mask_values=[0,1]
    zeta_fixed_mask.set_attr("flag_values", mask_values);
    zeta_fixed_mask.set_attr("flag_meanings","tauc_changable tauc_unchangeable");
    zeta_fixed_mask.output_data_type = PISM.PISM_BYTE;

    zeta_fixed_mask.set(1);
    with PISM.util.Access(comm=zeta_fixed_mask,nocomm=mask):
      mq = PISM.MaskQuery(mask)
      for (i,j) in self.grid.points():
        if mq.grounded_ice(i,j):
          zeta_fixed_mask[i,j] = 0;
    vecs.add(zeta_fixed_mask)

  def _constructSSA(self):
    """Returns an instance of :cpp:class:`IP_SSATaucForwardProblem` rather than
       a basic :cpp:class:`SSAFEM` or :cpp:class:`SSAFD`. Called from :meth:`PISM.ssa.SSARun.setup`."""
    md = self.modeldata
    self.tauc_param = createTaucParam(self.config)
    return createSSATaucForwardProblem(md.grid,md.basal,md.enthalpyconverter,self.tauc_param,self.config)

  def _initSSA(self):
    """One-time initialization of the :cpp:class:`IP_SSATaucForwardProblem`. Called from :meth:`PISM.ssa.SSARun.setup`."""

    vecs = self.modeldata.vecs

    if vecs.has('vel_bc'):
      self.ssa.set_boundary_conditions(vecs.bc_mask,vecs.vel_bc)

    if vecs.has('zeta_fixed_mask') and self.using_zeta_fixed_mask:
      self.ssa.set_tauc_fixed_locations(vecs.zeta_fixed_mask)

    self.ssa.init(vecs.asPISMVars())

    # Cache the values of the coefficeints at quadrature points once here.
    # Subsequent solves will then not need to cache these values.
    self.ssa.cacheQuadPtValues();


def createInvSSATaucSolver(ssarun,method=None):
  """Factory function returning an inverse solver appropriate for the config variable ``inv_ssa_method``.
  
  :param ssarun: an instance of :class:`SSATaucForwardRun:` or :class:`SSATaucForwardRunFromInputFile`.
  :param method: a string correpsonding to config variable ``inv_ssa_method`` describing the inversion method to be used.
  """ 
  if method is None:
    method = ssarun.config.get_string('inv_ssa_method')
  if method == 'tikhonov_gn':
    import invert_ssa_gn
    return invert_ssa_gn.InvSSASolver_Tikhonov(ssarun,method)    
  elif method.startswith('tikhonov'):
    if not has_tao:
      raise RuntimeError("Inversion method '%s' requires the TAO library.\nInstall from http://www.mcs.anl.gov/tao and rebuild PISM with TAO support." % method)
    import invert_ssa_tao
    return invert_ssa_tao.InvSSATaucSolver_Tikhonov(ssarun,method)
  if method == 'sd' or method == 'nlcg' or method == 'ign':
    if not has_siple:
      raise RuntimeError("Inversion method '%s' requires the siple python library.\nInstall from https://github.com/damaxwell/siple" % method)
    import invert_ssa_siple
    return invert_ssa_siple.InvSSASolver_Gradient(ssarun,method)
  raise Exception("Unknown inverse method '%s'; unable to construct solver.",method)


tauc_param_types = {"ident":PISM.IPTaucParamIdent, 
               "square":PISM.IPTaucParamSquare,
               "exp":PISM.IPTaucParamExp,
               "trunc":PISM.IPTaucParamTruncatedIdent }

def createTaucParam( config, name=None ):
  """Factory function for creating subclasses of :cpp:class:`IPTaucParameterization` based on command-line flags."""
  if name is None:
    name = PISM.optionsList(PISM.Context().com,"-inv_ssa_tauc_param","zeta->tauc parameterization",["ident","square","exp","trunc"],"")
    if name == "":
      name = config.get_string("inv_ssa_tauc_param")
  tauc_param = tauc_param_types[name]()
  tauc_param.init(config)
  return tauc_param


def createSSATaucForwardProblem(grid,basal,ec,tauc_param,config,name=None):
  """Returns an instance of :cpp:class:`IP_SSATaucForwardProblem` or its deprecated cousin
     :cpp:class:`IP_SSATaucForwardProblem_dep` based on ``-inv_old_siple``.  This function is here 
     only for testing purposes and will go away."""
  IP_SSATaucForwardProblem = PISM.IP_SSATaucForwardProblem
  if PISM.optionsFlag("inv_old_siple",""):
    IP_SSATaucForwardProblem = PISM.IP_SSATaucForwardProblem_dep
  return IP_SSATaucForwardProblem(grid,basal,ec,tauc_param,config)


def createTikhonovFunctionals(ssarun):
  """Returns a tuple ``(designFunctional,stateFunctional)`` of :cpp:class:`IP_Functional`\s 
  for Tikhonov-based inversions.  The specific functionals are constructed on the basis of 
  command-line parameters ``inv_ssa_misfit`` and ``inv_ssa_tauc_norm``.  
  
  :param ssarun: The instance of :class:`PISM.ssa.SSARun` that encapsulates the forward problem,
                 typically a :class:`SSATaucForwardRunFromFile`.
"""
  vecs = ssarun.modeldata.vecs
  grid = ssarun.grid

  misfit_weight = None
  if vecs.has('vel_misfit_weight'):
    misfit_weight = vecs.vel_misfit_weight

  tauc_fixed_mask = None
  if vecs.has('zeta_fixed_mask'):
    tauc_fixed_mask = vecs.zeta_fixed_mask

  misfit_type = "rms"
  for o in PISM.OptionsGroup(grid.com,"","SSATikhonovFunctionals"):
      useGroundedIceOnly = PISM.optionsIsSet("-inv_ssa_grounded_ice_tauc","Computed norms for tau_c only on elements with all grounded ice.")
      (misfit_type,wasSet) = PISM.optionsListWasSet(grid.com,'-inv_ssa_misfit',"Misfit functional type",['rms','log_relative','log_ratio'],'rms')

  tauc_norm = grid.config.get_string("inv_ssa_tauc_norm")
  if tauc_norm == "hilbert":
    cL2 = grid.config.get("inv_ssa_cL2");
    cH1 = grid.config.get("inv_ssa_cH1");

    area = 4*grid.Lx*grid.Ly;
    length_scale = grid.config.get("inv_ssa_length_scale");
    cL2 /= area;
    cH1 /= area;
    cH1 *= (length_scale*length_scale);


    if useGroundedIceOnly:
      ice_mask =vecs.ice_mask
      designFunctional = PISM.IPGroundedIceH1NormFunctional2S(grid,cL2,cH1,ice_mask,tauc_fixed_mask)
    else:
      designFunctional = PISM.IP_H1NormFunctional2S(grid,cL2,cH1,tauc_fixed_mask)

  elif tauc_norm == "tv":
    area = 4*grid.Lx*grid.Ly;
    length_scale = grid.config.get("inv_ssa_length_scale");
    lebesgue_exponent = grid.config.get("inv_ssa_tv_exponent");
    cTV = 1/area
    cTV *= (length_scale)**(lebesgue_exponent)
    designFunctional = PISM.IPTotalVariationFunctional2S(grid,cTV,lebesgue_exponent,tauc_fixed_mask)
  else:
    raise Exception("Unknown inv_ssa_tauc_norm '%s'; unable to construct solver.",tauc_norm)

  velocity_scale = grid.config.get("inv_ssa_velocity_scale", "m/year", "m/second")

  tauc_norm = grid.config.get_string("inv_ssa_tauc_norm")

  if misfit_type == "rms":  
    stateFunctional = PISM.IPMeanSquareFunctional2V(grid,misfit_weight);    
    stateFunctional.normalize(velocity_scale);
  elif misfit_type == "log_ratio":
    vel_ssa_observed = vecs.vel_ssa_observed
    stateFunctional = PISM.IPLogRatioFunctional(grid,vel_ssa_observed)
    stateFunctional.normalize(0.01);
  elif misfit_type == "log_relative":
    vel_ssa_observed = vecs.vel_ssa_observed
    stateFunctional = PISM.IPLogRelativeFunctional(grid,vel_ssa_observed)
    stateFunctional.normalize(1.);
  else:
    raise Exception("Unknown inv_ssa_misfit '%s'; unable to construct solver.",misfit_type)

  return (designFunctional,stateFunctional)


  vecs = ssarun.modeldata.vecs

  misfit_weight = None
  if vecs.has('vel_misfit_weight'):
    misfit_weight = vecs.vel_misfit_weight

  tauc_fixed_mask = None
  if vecs.has('zeta_fixed_mask'):
    tauc_fixed_mask = vecs.zeta_fixed_mask

  grid = ssarun.grid


  misfit_type = "rms"
  for o in PISM.OptionsGroup(grid.com,"","SSATikhonovFunctionals"):
      useGroundedIceOnly = PISM.optionsIsSet("-inv_ssa_grounded_ice_tauc","Computed norms for tau_c only on elements with all grounded ice.")
      (misfit_type,wasSet) = PISM.optionsListWasSet(grid.com,'-inv_ssa_misfit',"Misfit functional type",['rms','log_relative','log_ratio'],'rms')

  tauc_norm = grid.config.get_string("inv_ssa_tauc_norm")
  if tauc_norm == "hilbert":
    cL2 = grid.config.get("inv_ssa_cL2");
    cH1 = grid.config.get("inv_ssa_cH1");

    area = 4*grid.Lx*grid.Ly;
    length_scale = grid.config.get("inv_ssa_length_scale");
    cL2 /= area;
    cH1 /= area;
    cH1 *= (length_scale*length_scale);


    if useGroundedIceOnly:
      ice_mask =vecs.ice_mask
      designFunctional = PISM.IPGroundedIceH1NormFunctional2S(grid,cL2,cH1,ice_mask,tauc_fixed_mask)
    else:
      designFunctional = PISM.IP_H1NormFunctional2S(grid,cL2,cH1,tauc_fixed_mask)

  elif tauc_norm == "tv":
    area = 4*grid.Lx*grid.Ly;
    length_scale = grid.config.get("inv_ssa_length_scale");
    lebesgue_exponent = grid.config.get("inv_ssa_tv_exponent");
    cTV = 1/area
    cTV *= (length_scale)**(lebesgue_exponent)
    designFunctional = PISM.IPTotalVariationFunctional2S(grid,cTV,lebesgue_exponent,tauc_fixed_mask)
  else:
    raise Exception("Unknown inv_ssa_tauc_norm '%s'; unable to construct solver.",tauc_norm)

  velocity_scale = grid.config.get("inv_ssa_velocity_scale", "m/year", "m/second")

  tauc_norm = grid.config.get_string("inv_ssa_tauc_norm")

  if misfit_type == "rms":  
    stateFunctional = PISM.IPMeanSquareFunctional2V(grid,misfit_weight);    
    stateFunctional.normalize(velocity_scale);
  elif misfit_type == "log_ratio":
    vel_ssa_observed = vecs.vel_ssa_observed
    stateFunctional = PISM.IPLogRatioFunctional(grid,vel_ssa_observed)
    stateFunctional.normalize(0.01);
  elif misfit_type == "log_relative":
    vel_ssa_observed = vecs.vel_ssa_observed
    stateFunctional = PISM.IPLogRelativeFunctional(grid,vel_ssa_observed)
    stateFunctional.normalize(1.);
  else:
    raise Exception("Unknown inv_ssa_misfit '%s'; unable to construct solver.",misfit_type)

  return (designFunctional,stateFunctional)


class PrintTikhonovProgress:
  """Iteration listener that prints diagnostic information suitable for 
  Tikhonov-based inversions."""
  def __init__(self):
    self.misfit_type = None
    self.misfit_history = []

  def __call__(self,invssasolver,it,data):
    eta = data.eta
    stateVal = data.stateVal
    designVal = data.designVal
    grid = invssasolver.ssarun.grid
    velScale_m_per_year = invssasolver.ssarun.config.get("inv_ssa_velocity_scale")
    velScale_m_per_s = grid.convert(velScale_m_per_year, "m/year", "m/second")
    sWeight = 1
    dWeight = 1./eta

    logMessage("----------------------------------------------------------\n");
    logMessage("Iteration %d\n" % it)    

    if self.misfit_type is None:
      for o in PISM.OptionsGroup(grid.com,"","SSATikhonovFunctionals"):
        (self.misfit_type,wasSet) = PISM.optionsListWasSet(grid.com,'-inv_ssa_misfit',"Misfit functional type",['rms','log_relative','log_ratio'],'rms')
      if self.misfit_type!="rms":
        self.stateFunctional = PISM.IPMeanSquareFunctional2V(grid);    
        self.stateFunctional.normalize(velScale_m_per_s);

    if self.misfit_type=="rms":
      misfit = math.sqrt(stateVal)*velScale_m_per_year
    else:
      misfit = math.sqrt(self.stateFunctional.valueAt(data.r))*velScale_m_per_year

    logMessage("RMS misfit: %.8g\n" % misfit)
    self.misfit_history.append(misfit)

    logMessage("design objective %.8g; weighted %.8g\n" % (designVal,designVal*dWeight)) 
    if data.has_key('grad'):
      logMessage("gradient: design %.8g state %.8g sum %.8g\n" % (data.grad_zeta.norm(PETSc.NormType.NORM_2)*dWeight,data.grad_u.norm(PETSc.NormType.NORM_2)*sWeight,data.grad.norm(PETSc.NormType.NORM_2)))
    else:
      logMessage("gradient: design %.8g state %.8g; constraints: %.8g\n" % (data.grad_zeta.norm(PETSc.NormType.NORM_2)*dWeight,data.grad_u.norm(PETSc.NormType.NORM_2)*sWeight,data.constraints.norm(PETSc.NormType.NORM_2)))
    logMessage("tikhonov functional: %.8g\n" % (stateVal*sWeight + designVal*dWeight) )

  def write(self,output_filename):
    """Saves a history of RMS misfits as ``inv_ssa_iter``
    
    :param output_filename: filename to save misfits to."""
    if len(self.misfit_history) == 0:
      return
    if PISM.Context().rank == 0:
      nc = netCDF.Dataset(output_filename, 'a')  # append
      nc.createDimension('inv_ssa_iter',len(self.misfit_history))
      nc_misfit = nc.createVariable('inv_ssa_misfit','f8',dimensions=('inv_ssa_iter'))
      nc_misfit.setncattr('_units','m/a')
      nc_misfit[:] = self.misfit_history[:]
      nc.close()

class MonitorAdjoint:
  """Iteration listener that can be used to verify the correctness of the implementation of an adjoint.
  For adjoint-based interative inverse methods, a residual ``r`` is known in state space and a step direction ``d`` is 
  known in design space.  A linearized forward problem :math:`T` maps from design space to state space, and its adjoint :math:`T^*`
  goes in the opposite direction.  The inner products :math:`\left<Td,r\\right>_{\\rm State}` 
  and :math:`\left<d,T^*r\\right>_{\\rm Design}` should always be the same; this is a good diagnostic to determine
  of an adjoint has been coded correctly. The listener prints a comparison of the values of the two inner products
  at each iteration.  
  """

  def __init__(self):
    self.Td = None
    self.TStarR = None
    self.didWarning = False

  def __call__(self,inverse_solver,count,data):
    """
    :param inverse_sovler: the solver (e.g. :class:`~InvSSASolver_Tikhonov`) we are listening to.
    :param count: the iteration number.
    :param data: dictionary of data related to the iteration.
    """
    import PISM.sipletools
    method = inverse_solver.method
    if method != 'sd' and method !='nlcg' and method != 'ign':
      if not self.didWarning:
        PISM.verbPrintf(1,PISM.Context().com,'\nWarning: unable to monitor adjoint for inverse method: %s\nOption -inv_monitor_adjoint ignored\n' % method)
      self.didWarning = True
      return
    fp = inverse_solver.forward_problem
    d = PISM.sipletools.PISMLocalVector(data.d)
    r = PISM.sipletools.PISMLocalVector(data.r)
    self.Td=fp.T(d,self.Td)
    self.TStarR=forward_problem.TStar(r,out=self.TStarR)
    ip1 = fp.domainIP(d,self.TStarR)
    ip2 = fp.rangeIP(self.Td,r)
    logMessage("adjoint test: <Td,r>=%g <d,T^*r>=%g (percent error %g)",ip1,ip2,(abs(ip1-ip2))/max(abs(ip1),abs(ip2)))


class MonitorAdjointLin:
  def __init__(self):
    self.Td = None
    self.TStarR = None

  def __call__(self,inverse_solver,count,data):
    """
    :param inverse_sovler: the solver (e.g. :class:`~InvSSASolver_Tikhonov`) we are listening to.
    :param count: the iteration number.
    :param data: dictionary of data related to the iteration.
    """
    import PISM.sipletools
    fp = inverse_solver.forward_problem
    r = PISM.sipletools.PISMLocalVector(data.r)
    d = PISM.sipletools.PISMLocalVector(data.d)
    self.Td=fp.T(d,self.Td)
    self.TStarR=forward_problem.TStar(r,out=self.TStarR)
    ip1 = fp.domainIP(d,self.TStarR)
    ip2 = fp.rangeIP(self.Td,r)
    logMessage("adjoint test: <Td,r>=%g <d,T^*r>=%g (percent error %g)",ip1,ip2,(abs(ip1-ip2))/max(abs(ip1),abs(ip2)))

class PrintRMSMisfit:
  def __init__(self):
    self.misfit_history = []
  def __call__(self,invssa_solver,it,data):
    """
    :param inverse_sovler: the solver (e.g. :class:`~InvSSASolver_Tikhonov`) we are listening to.
    :param count: the iteration number.
    :param data: dictionary of data related to the iteration.
    """
    if invssa_solver.method.startswith('tikhonov'):
      raise NotImplementedError()
    else:
      import PISM.sipletools
      fp = invssa_solver.forward_problem
      r=PISM.sipletools.PISMLocalVector(data.r)
      rms_misfit = math.sqrt(fp.rangeIP(r,r))
    logMessage("Iteration [%d]: RMS misfit %.8g\n" % (it,rms_misfit));
    self.misfit_history.append(rms_misfit)
  def write(self,output_filename):
    """Saves a history of RMS misfits as ``inv_ssa_iter``
    
    :param output_filename: filename to save misfits to."""
    if PISM.Context().rank == 0:
      nc = netCDF.Dataset(output_filename, 'a')  # append
      nc.createDimension('inv_ssa_iter',len(self.misfit_history))
      nc_misfit = nc.createVariable('inv_ssa_misfit','f8',dimensions=('inv_ssa_iter'))
      nc_misfit.setncattr('_units','m/a')
      nc_misfit[:] = self.misfit_history[:]
      nc.close()

class ZetaSaver:
  """Iteration listener used to save a copy of the current value
  of :math:`\zeta` (i.e. a parameterized :math:`\tau_c`) at each iteration during an inversion.
  The intent is to use a saved value to restart an inversion if need be.
  """
  def __init__(self,output_filename):
    """:param output_filename: file to save iterations to."""
    self.output_filename = output_filename

  def __call__(self,inverse_solver,count,data):
    zeta = data.zeta
    # The solver doesn't care what the name of zeta is, and we
    # want it called 'zeta_inv' in the output file, so we rename it.
    zeta.rename('zeta_inv', 'last iteration of parameterized basal yeild stress computed by inversion','')
    zeta.write(self.output_filename)


def pauseListener(*args):
  """Listener that temporarily halts operation at each iteration waiting for a key press."""
  PISM.logging.pause()

class PlotListener:
  """Base class for listeners that create plots of vectors at each iteration. 
Provides objects for converting :cpp:class:`IceModelVec`\'s to ``numpy`` vectors
on processor zero, as well as basic ``matplotlib`` figure management."""
  def __init__(self,grid):
    self.grid = grid
    self.tz_scalar = PISM.toproczero.ToProcZero(grid,dof=1)
    self.tz_vector = PISM.toproczero.ToProcZero(grid,dof=2)
    self.figs = {}

  def toproczero(self,*args):
    """Returns a ``numpy`` vector on processor zero corresponding to an :cpp:class:`IceModelVec`.
    Takes as input either a single :cpp:class:`IceModelVec` or dictionary of such
    vectors and the name of an entry. Returns ``None`` on other processors."""
    if len(args) == 2:
      data = args[0]
      name = args[1]
      v = data[name]
    else:
      v = args[0]
    if v is None:
      return None
    if v.get_dof()==1:
      return self.tz_scalar.communicate(v)
    return self.tz_vector.communicate(v)

  def figure(self,name='default'):
    """Returns a ``matplotlib`` figure based on a string name.  If the instance has not yet
    created a figure with the given name, a new figure is created and associated with the given name."""
    fig = self.figs.get(name)
    if fig is None:
      import matplotlib.pyplot as pp
      fig = pp.figure()
      self.figs[name]=fig
    return fig.number

  def __call__(self,solver,itr,data):
    raise NotImplementedError()



