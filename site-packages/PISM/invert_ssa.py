# Copyright (C) 2011, 2012 David Maxwell
# 
# This file is part of PISM.
# 
# PISM is free software; you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# 
# PISM is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
# 
# You should have received a copy of the GNU General Public License
# along with PISM; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

import PISM

has_siple = False
try:
  import siple
  has_siple = True
except:
  pass

has_tao = False
try:
  PISM.__getattribute__('InvSSATikhonov')
  has_tao = True
except:
  pass

import math
from petsc4py import PETSc

from PISM.logging import logError, logMessage
import numpy as np
import sys

tauc_param_types = {"ident":PISM.InvTaucParamIdent, 
               "square":PISM.InvTaucParamSquare,
               "exp":PISM.InvTaucParamExp,
               "trunc":PISM.InvTaucParamTruncatedIdent }

class TaucParamFactory:
  def create(self, config, name=None ):
    if name is None:
      name = PISM.optionsList(PISM.Context().com,"-inv_ssa_tauc_param","zeta->tauc parameterization",["ident","square","exp","trunc"],"")
      if name == "":
        name = config.get_string("inv_ssa_tauc_param")
    tauc_param = tauc_param_types[name]()
    tauc_param.init(config)
    return tauc_param

tauc_param_factory = TaucParamFactory()

def invSSAFactory(grid,basal,ec,tauc_param,config,name=None):
  if name is None:
    name = config.get_string("inv_ssa_method")
  if name.startswith('tikhonov'):
    if not has_tao:
      raise RuntimeError("Inversion method '%s' requires the TAO library.\nInstall from http://www.mcs.anl.gov/tao and rebuild PISM with TAO support." % name)    
    return PISM.InvSSATikhonov(grid,basal,ec,tauc_param,config)
  if not has_siple:
    raise RuntimeError("Inversion method '%s' requires the siple python library.\nInstall from https://github.com/damaxwell/siple" % name)
  return PISM.InvSSAForwardProblem(grid,basal,ec,tauc_param,config)

class InvSSARun(PISM.ssa.SSARun):

  def setup(self):

    PISM.ssa.SSARun.setup(self)

    vecs = self.modeldata.vecs

    # The SSA instance will not keep a reference to pismVars; it only uses it to extract
    # its desired variables.  So it is safe to pass it pismVars and then let pismVars
    # go out of scope at the end of this method.

    self.ssa.init(vecs.asPISMVars())

    if vecs.has('vel_bc'):
      self.ssa.set_boundary_conditions(vecs.bc_mask,vecs.vel_bc)

    # Cache the values of the coefficients at quadrature points once here.
    # Subsequent solves will then not need to cache these values.
    self.ssa.cacheQuadPtValues();

    # YUCK
    inv_method = self.config.get_string('inv_ssa_method');
    if inv_method.startswith('tikhonov'):
      self.ssa.set_functionals()

  def _constructSSA(self):
    md = self.modeldata
    self.tauc_param = tauc_param_factory.create(self.config)
    return invSSAFactory(md.grid,md.basal,md.enthalpyconverter,self.tauc_param,self.config)

def InvSSASolver(ssarun):
  """Returns an inverse solver appropriate for the config variable 'inv_ssa_method'.
  The problem :ssarun: should be a subclass of :InvSSARun:.""" 
  method = ssarun.config.get_string('inv_ssa_method')
  if method.startswith('tikhonov'):
    if not has_tao:
      raise RuntimeError("Inversion method '%s' requires the TAO library.\nInstall from http://www.mcs.anl.gov/tao and rebuild PISM with TAO support." % method)
    import invert_ssa_tao
    return invert_ssa_tao.InvSSASolver_Tikhonov(ssarun)
  if method == 'sd' or method == 'nlcg' or method == 'ign':
    if not has_siple:
      raise RuntimeError("Inversion method '%s' requires the siple python library.\nInstall from https://github.com/damaxwell/siple" % method)
    import invert_ssa_siple
    return invert_ssa_siple.InvSSASolver_Siple(ssarun)
  raise Exception("Unknown inverse method '%s'; unable to construct solver.",method)

def printTikhonovProgress(invssasolver,it,data):
  eta = data.eta
  stateVal = data.stateVal
  designVal = data.designVal
  velScale = invssasolver.ssarun.config.get("inv_ssa_velocity_scale");

  sWeight = 1
  dWeight = 1./eta

  logMessage("----------------------------------------------------------\n");
  logMessage("Iteration %d\n" % it)    
  logMessage("RMS misfit: %g\n" % (math.sqrt(stateVal)*velScale))
  logMessage("sqrt(design objective) %g; weighted %g\n" % (math.sqrt(designVal),math.sqrt(designVal*dWeight))) 
  if data.has_key('grad'):
    logMessage("gradient: design %g state %g sum %g\n" % (data.grad_zeta.norm(PETSc.NormType.NORM_2)*dWeight,data.grad_u.norm(PETSc.NormType.NORM_2)*sWeight,data.grad.norm(PETSc.NormType.NORM_2)))
  else:
    logMessage("gradient: design %g state %g; constraints: %g\n" % (data.grad_zeta.norm(PETSc.NormType.NORM_2)*dWeight,data.grad_u.norm(PETSc.NormType.NORM_2)*sWeight,data.constraints.norm(PETSc.NormType.NORM_2)))
  logMessage("tikhonov functional: %g\n" % (stateVal*sWeight + designVal*dWeight) )

class MonitorAdjoint:
  def __init__(self):
    self.Td = None
    self.TStarR = None
    self.didWarning = False

  def __call__(self,inverse_solver,count,data):
    import PISM.sipletools
    method = inverse_solver.method
    if method != 'sd' and method !='nlcg' and method != 'ign':
      if not self.didWarning:
        PISM.verbPrintf(1,PISM.Context().com,'\nWarning: unable to monitor adjoint for inverse method: %s\nOption -inv_monitor_adjoint ignored\n' % method)
      self.didWarning = True
      return
    fp = inverse_solver.forward_problem
    d = PISM.sipletools.PISMLocalVector(data.d)
    r = PISM.sipletools.PISMLocalVector(data.r)
    self.Td=fp.T(d,self.Td)
    self.TStarR=forward_problem.TStar(r,out=self.TStarR)
    ip1 = fp.domainIP(d,self.TStarR)
    ip2 = fp.rangeIP(self.Td,r)
    logMessage("adjoint test: <Td,r>=%g <d,T^*r>=%g (percent error %g)",ip1,ip2,(abs(ip1-ip2))/max(abs(ip1),abs(ip2)))


class MonitorAdjointLin:
  def __init__(self):
    self.Td = None
    self.TStarR = None

  def __call__(self,inverse_solver,count,data):
    import PISM.sipletools
    fp = inverse_solver.forward_problem
    r = PISM.sipletools.PISMLocalVector(data.r)
    d = PISM.sipletools.PISMLocalVector(data.d)
    self.Td=fp.T(d,self.Td)
    self.TStarR=forward_problem.TStar(r,out=self.TStarR)
    ip1 = fp.domainIP(d,self.TStarR)
    ip2 = fp.rangeIP(self.Td,r)
    logMessage("adjoint test: <Td,r>=%g <d,T^*r>=%g (percent error %g)",ip1,ip2,(abs(ip1-ip2))/max(abs(ip1),abs(ip2)))

def printRMSMisfit(invssa_solver,it,data):
  if invssa_solver.method.startswith('tikhonov'):
    rms_misfit = math.sqrt(data.stateVal)
  else:
    import PISM.sipletools
    fp = invssa_solver.forward_problem
    r=PISM.sipletools.PISMLocalVector(data.r)
    rms_misfit = math.sqrt(fp.rangeIP(r,r))
  logMessage("Iteration [%d]: RMS misfit %g\n" % (it,rms_misfit));

class ZetaSaver:
  """Iteration listener used to save a copy of the current value
  of zeta (i.e. parameterized tauc) at each iteration during an inversion."""
  def __init__(self,output_filename):
    self.output_filename = output_filename

  def __call__(self,inverse_solver,count,data):
    zeta = data.zeta
    # The solver doesn't care what the name of zeta is, and we
    # want it called 'zeta_inv' in the output file, so we rename it.
    zeta.rename('zeta_inv', 'last iteration of parameterized basal yeild stress computed by inversion','')
    zeta.write(self.output_filename)


def pauseListener(*args):
  PISM.logging.pause()

class PlotListener:
  def __init__(self,grid):
    self.grid = grid
    self.tz_scalar = PISM.toproczero.ToProcZero(grid,dof=1)
    self.tz_vector = PISM.toproczero.ToProcZero(grid,dof=2)
    self.figs = {}

  def toproczero(self,*args):
    if len(args) == 2:
      data = args[0]
      name = args[1]
      v = data[name]
    else:
      v = args[0]
    if v is None:
      return None
    if v.get_dof()==1:
      return self.tz_scalar.communicate(v)
    return self.tz_vector.communicate(v)

  def figure(self,name='default'):
    fig = self.figs.get(name)
    if fig is None:
      import matplotlib.pyplot as pp
      fig = pp.figure()
      self.figs[name]=fig
    return fig.number

  def iteration(self,solver,itr,data):
    # Subclasses should implement this method to do 
    # the plotting. This method will only be called on
    # processor zero, and the arguments will all be numpy
    # vectors already copied to proc 0.
    raise NotImplementedError()



