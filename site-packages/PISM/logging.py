# Copyright (C) 2012 David Maxwell
# 
# This file is part of PISM.
# 
# PISM is free software; you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# 
# PISM is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
# 
# You should have received a copy of the GNU General Public License
# along with PISM; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

import PISM
import time

def print_logger(message,verbosity):
  """Implements a logger that prints output to the terminal."""
  com = PISM.Context().com
  msg = str(message)
  PISM.verbPrintf(verbosity,com, msg)

_loggers = [ print_logger ]

kError = 1
kWarning = 2
kMessage = 2
kDebug   = 4
kPrattle = 5

def clear_loggers():
  global _loggers
  _loggers = []

def add_logger(logger):
  global _loggers
  _loggers.append(logger)

def log(message,verbosity):
  for l in _loggers:
    l(message,verbosity)

def logError(message):
  log(message,kError)

def logWarning(message):
  log(message,kWarning)

def logMessage(message):
  log(message,kMessage)

def logDebug(message):
  log(message,kDebug)

def logPrattle(message):
  log(message,kPrattle)


class CaptureLogger:
  """Implements a logger that appends log messages as they occur 
  to an attribute of an NC file."""
  def __init__(self,filename,attribute='pism_log'):
    self.com = PISM.Context().com
    self.rank = PISM.Context().rank
    self.log = ""
    self.filename = filename
    self.attr = attribute

  def __call__(self,message,verbosity):
    if self.rank == 0 and  PISM.getVerbosityLevel() >= verbosity:
      timestamp = time.strftime('%Y-%m-%d %H:%M:%S')
      self.log = "%s%s: %s" % (self.log,timestamp,message)
      d = PISM.netCDF.Dataset(self.filename,'a')
      d.__setattr__(self.attr,self.log)
      d.close()
    self.com.barrier()

  def readOldLog(self):
    if PISM.Context().rank == 0:
      d = PISM.netCDF.Dataset(self.filename,'a')
      if self.attr in d.ncattrs():
        self.log += d.__getattr__(self.attr)
      d.close()
    self.com.barrier()

  def write(self,filename=None,attribute=None):
    if filename is None:
      filename = self.filename
    if attribute is None:
      attribute = self.attr
    if PISM.Context().rank == 0:
      d = PISM.netCDF.Dataset(filename,'a')
      d.__setattr__(attribute,self.log)
      d.close()
    self.com.barrier()


import termios, sys, os
TERMIOS = termios
def getkey():
  fd = sys.stdin.fileno()
  c = None
  if os.isatty(fd):
    old = termios.tcgetattr(fd)
    new = termios.tcgetattr(fd)
    new[3] = new[3] & ~TERMIOS.ICANON & ~TERMIOS.ECHO
    new[6][TERMIOS.VMIN] = 1
    new[6][TERMIOS.VTIME] = 0
    termios.tcsetattr(fd, TERMIOS.TCSANOW, new)
    try:
            c = os.read(fd, 1)
    finally:
            termios.tcsetattr(fd, TERMIOS.TCSAFLUSH, old)
  else:
    # FIXME: The following is here for multi-processor runs.  
    # Termios is not available and I don't know a better solution.  
    c  = sys.stdin.read(1)
  return c
  
def pause(message_in=None,message_out=None):
  com = PISM.Context().com
  if not message_in is None:
    PISM.verbPrintf(1,com,message_in+"\n")
  c = getkey()
  if not message_out is None:
    PISM.verbPrintf(1,com,message_out+"\n")
