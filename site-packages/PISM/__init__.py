# Copyright (C) 2011 David Maxwell
# 
# This file is part of PISM.
# 
# PISM is free software; you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation; either version 3 of the License, or (at your option) any later
# version.
# 
# PISM is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
# 
# You should have received a copy of the GNU General Public License
# along with PISM; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

import petsc4py
try:
  # Look if petsc4py has already been initialized
  PETSc = petsc4py.__getattribute__('PETSc')
except:
  # If not, initialize petsc4py with the PETSc that PISM was compiled against.
  import sys
  from PISM.petsc_version import PISM_PETSC_ARCH
  petsc4py.init(sys.argv,arch=PISM_PETSC_ARCH)
from petsc4py import PETSc

try:
  import netCDF4 as netCDF
except:
  import netCDF3 as netCDF
from PISM.cpp import *
from PISM.options import *
import cpp
import util
import ssa
import sia
import toproczero
import logging

class Context(object):
  """Maintains PISM data that needs to exist only once per processor.

  * ``com``    an MPI Comm
  * ``rank``   the MPI rank of the current processor
  * ``size``   the number of processors
  * ``config`` an :cpp:class:`NCConfigVariable`
  
There is only ever one :class:`Context`. If you make another one, you'll get
the first one.  You obtain the singleton as so::
  
  context = PISM.Context()

The ``config`` member variable is initialized the first time it is accessed.  Optionally
use :meth:`init_config` to perform initialization (e.g. overides) before accessing it.
"""

  # Implement a Singleton pattern by overriding __new__
  _instance = None
  def __new__(cls):
    if cls._instance is None:
      cls._instance = super(Context,cls).__new__(cls)
      cls._instance.__init_once__()
    return cls._instance

  # Since __init__ is always called after __new__, we don't
  # want to put code that only gets run once in __init__.
  def __init_once__(self):
    self.com = PETSc.COMM_WORLD
    self.rank = PETSc.Comm.getRank(self.com)
    self.size = PETSc.Comm.getSize(self.com)
    self._config = None
  
  def __getattr__(self,key):
    """We want the variable 'config' to look like a member.  We  also want to 
    delay initializing it until after the user has had a chance to do
    custom initialization with Context.init_config.  And we want to
    perform a default initialization if the user accesses config without
    performing a custom initialization.  This method makes 'config'
    look like a member and performs initialization if it has not already
    been done.
    """
    if key == 'config':
      if self._config is None:
        self.init_config()
      return self._config
    raise AttributeError(key)

  def init_config(self,overrides=None,use_command_line_options=True):
    """Initializes the global :cpp:class:`NCConfigVariable`.

      :param overrides: a filename contianing variable overrides.
      :param use_command_line_options: boolean indicating if variables should be overridden by
                                       their command-line counterparts or not."""
    if not self._config is None:
      raise RuntimeError("global config already initialized")
    system = PISM.PISMUnitSystem(None)
    self._config = NCConfigVariable(system)
    if overrides is None:
      overrides = NCConfigVariable(system)
    init_config(self.com, self.rank, self.config, overrides)
    if use_command_line_options:
      set_config_from_options(self.com,self._config)

  def newgrid(self):
    "Convenience method to construct a new grid using data from the :class:`Context`."
    return IceGrid(self.com,self.rank,self.size,self.config)

class AlgorithmFailureException(Exception):
  """Python exception wrapping a PISM :cpp:class:`TerminationReason`"""

  def __init__(self,reason):
    """:param reason: a :cpp:class:`TerminationReason`"""
    self._reason = reason
  def __str__(self):
    return self._reason.nested_description()
  def reason(self):
    return _reason

def verbPrintf(verbosity,com,msg,*args):
  """Mimics PISM's :cpp:func:`verbPrintf` but does formatting on the python side."""
  if len(args) > 0:
    msg = msg % args
  cpp._verbPrintf(verbosity,com,msg)
